<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CYPHER GROK TRADE | Terminal</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
:root {
    --neon-green: #00ff88;
    --neon-cyan: #00f0ff;
    --neon-purple: #a855f7;
    --neon-pink: #ff00aa;
    --neon-red: #ff3333;
    --neon-yellow: #ffdd00;
    --neon-orange: #ff8800;
    --dark-bg: #050508;
    --card-bg: #0a0a12;
    --card-border: #1a1a2a;
    --text-primary: #c0c0c8;
    --text-dim: #5a5a78;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--dark-bg);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
}
body::after {
    content: '';
    position: fixed; top:0; left:0; width:100%; height:100%;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,136,0.008) 2px, rgba(0,255,136,0.008) 4px);
    pointer-events: none; z-index: 9999;
}
body::before {
    content: '';
    position: fixed; top:0; left:0; width:100%; height:100%;
    background-image:
        linear-gradient(rgba(0,255,136,0.015) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,255,136,0.015) 1px, transparent 1px);
    background-size: 30px 30px;
    pointer-events: none; z-index: 0;
}

/* HEADER */
.header {
    border-bottom: 1px solid var(--card-border);
    padding: 10px 20px;
    display: flex; align-items: center; justify-content: space-between;
    position: relative; z-index: 1;
    background: rgba(5,5,8,0.95);
}
.header-left { display: flex; align-items: center; gap: 12px; }
.logo {
    font-family: 'Orbitron', sans-serif;
    font-size: 13px; font-weight: 900;
    background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.status-badge {
    font-size: 9px; padding: 2px 8px;
    border-radius: 3px; text-transform: uppercase;
    font-weight: 700; letter-spacing: 1px;
}
.status-live { background: rgba(0,255,136,0.15); color: var(--neon-green); border: 1px solid rgba(0,255,136,0.3); }
.status-offline { background: rgba(255,51,51,0.15); color: var(--neon-red); border: 1px solid rgba(255,51,51,0.3); }
.header-right { font-size: 11px; color: var(--text-dim); }
#clock { color: var(--neon-cyan); }

/* MAIN LAYOUT */
.main {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto 1fr;
    grid-template-areas:
        "stats stats"
        "terminal terminal";
    gap: 1px; padding: 1px; position: relative; z-index: 1;
    height: calc(100vh - 46px);
}
@media (max-width: 768px) {
    .main { grid-template-columns: 1fr; grid-template-areas: "stats" "terminal"; }
}
.panel-stats { grid-area: stats; }
.panel-terminal { grid-area: terminal; }

/* PANELS */
.panel {
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    display: flex; flex-direction: column;
    overflow: hidden;
}
.panel-header {
    padding: 6px 14px;
    border-bottom: 1px solid var(--card-border);
    display: flex; align-items: center; justify-content: space-between;
    font-size: 10px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 2px;
    color: var(--text-dim);
    background: rgba(10,10,18,0.8);
    flex-shrink: 0;
}
.panel-header .title { display:flex; align-items:center; gap:8px; }
.panel-header .dot { width:6px; height:6px; border-radius:50%; }
.dot-green { background: var(--neon-green); box-shadow: 0 0 6px var(--neon-green); }
.dot-cyan { background: var(--neon-cyan); box-shadow: 0 0 6px var(--neon-cyan); }

/* STATS BAR */
.stats-bar {
    display: flex; gap: 4px; padding: 10px 14px; flex-wrap: wrap;
}
.stat-box {
    flex: 1; min-width: 90px;
    background: rgba(0,255,136,0.03);
    border: 1px solid rgba(0,255,136,0.08);
    border-radius: 4px; padding: 6px 8px;
    text-align: center;
}
.stat-label { font-size: 8px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; }
.stat-value { font-size: 15px; font-weight: 700; color: var(--neon-green); }
.stat-value.red { color: var(--neon-red); }
.stat-value.cyan { color: var(--neon-cyan); }
.stat-value.purple { color: var(--neon-purple); }
.stat-value.yellow { color: var(--neon-yellow); }
.stat-value.orange { color: var(--neon-orange); }

/* TERMINAL */
.terminal-body {
    flex: 1; overflow-y: auto; padding: 10px 14px;
    font-size: 12px; line-height: 1.6;
}
.terminal-body::-webkit-scrollbar { width: 4px; }
.terminal-body::-webkit-scrollbar-track { background: transparent; }
.terminal-body::-webkit-scrollbar-thumb { background: var(--card-border); border-radius: 2px; }

.term-line { white-space: pre-wrap; word-break: break-all; }
.term-line .prompt { color: var(--neon-green); }
.term-line .cmd { color: var(--neon-cyan); }
.green { color: var(--neon-green); }
.red { color: var(--neon-red); }
.cyan { color: var(--neon-cyan); }
.purple { color: var(--neon-purple); }
.yellow { color: var(--neon-yellow); }
.orange { color: var(--neon-orange); }
.pink { color: var(--neon-pink); }
.dim { color: var(--text-dim); }
.bold { font-weight: 700; }

/* INPUT LINE */
.terminal-input-line {
    display: flex; align-items: center; gap: 4px;
    padding: 8px 14px;
    border-top: 1px solid var(--card-border);
    background: rgba(5,5,8,0.9);
    flex-shrink: 0;
}
.terminal-input-line .prompt { color: var(--neon-green); font-size: 12px; font-weight: 700; }
#termInput {
    flex: 1; background: transparent; border: none; outline: none;
    color: var(--neon-cyan); font-family: 'JetBrains Mono', monospace;
    font-size: 12px; caret-color: var(--neon-green);
}
#termInput::placeholder { color: var(--text-dim); }

/* CURSOR */
@keyframes blink { 50% { opacity:0; } }
.cursor { display:inline-block; width:7px; height:13px; background:var(--neon-green); animation: blink 1s step-end infinite; vertical-align: middle; margin-left: 2px; }
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.3;} }
.pulse { animation: pulse 2s ease-in-out infinite; }

/* TABLES */
.term-table { width: 100%; font-size: 11px; border-collapse: collapse; margin: 4px 0; }
.term-table th { color: var(--text-dim); text-align: left; padding: 3px 6px; border-bottom: 1px solid var(--card-border); font-weight: 600; font-size: 9px; text-transform: uppercase; letter-spacing: 1px; }
.term-table td { padding: 3px 6px; border-bottom: 1px solid rgba(26,26,42,0.3); }
.term-table tr:hover td { background: rgba(0,255,136,0.02); }

/* PNL CHART (ASCII) */
.chart-bar {
    display: inline-block; height: 10px; border-radius: 1px;
    transition: width 0.3s;
}
.chart-bar.positive { background: var(--neon-green); }
.chart-bar.negative { background: var(--neon-red); }
</style>
</head>
<body>

<div class="header">
    <div class="header-left">
        <span class="logo">CYPHER GROK TRADE</span>
        <span id="statusBadge" class="status-badge status-live">LIVE</span>
        <span style="font-size:9px;color:var(--text-dim)">v3.1</span>
    </div>
    <div class="header-right">
        <span id="clock"></span> <span style="color:var(--text-dim)">|</span>
        <span id="uptime" style="color:var(--neon-green)">--</span>
    </div>
</div>

<div class="main">
    <!-- TOP: STATS BAR -->
    <div class="panel panel-stats">
        <div class="panel-header">
            <div class="title"><span class="dot dot-green"></span> ACCOUNT</div>
            <span class="pulse" style="color:var(--neon-green);font-size:9px">LIVE</span>
        </div>
        <div class="stats-bar">
            <div class="stat-box"><div class="stat-label">Balance</div><div class="stat-value" id="balance">--</div></div>
            <div class="stat-box"><div class="stat-label">Session PnL</div><div class="stat-value" id="pnl">--</div></div>
            <div class="stat-box"><div class="stat-label">Total PnL</div><div class="stat-value" id="totalPnl">--</div></div>
            <div class="stat-box"><div class="stat-label">Win Rate</div><div class="stat-value purple" id="winrate">--</div></div>
            <div class="stat-box"><div class="stat-label">W / L</div><div class="stat-value cyan" id="wl">--</div></div>
            <div class="stat-box"><div class="stat-label">Positions</div><div class="stat-value yellow" id="positions">--</div></div>
            <div class="stat-box"><div class="stat-label">Scans</div><div class="stat-value orange" id="scans">--</div></div>
        </div>
    </div>

    <!-- BOTTOM: INTERACTIVE TERMINAL -->
    <div class="panel panel-terminal">
        <div class="panel-header">
            <div class="title"><span class="dot dot-cyan"></span> TERMINAL</div>
            <span style="color:var(--text-dim);font-size:9px">type <span class="cyan">help</span> for commands</span>
        </div>
        <div class="terminal-body" id="termOutput"></div>
        <div class="terminal-input-line">
            <span class="prompt">cypher $</span>
            <input type="text" id="termInput" placeholder="type a command..." autocomplete="off" spellcheck="false">
        </div>
    </div>
</div>

<script>
// ====== GLOBAL STATE ======
let cachedStatus = null;
let cachedTrades = null;
let cachedPnl = null;
let cachedSignals = null;
let cachedConfig = null;
let cachedLearning = null;
let cmdHistory = [];
let cmdIdx = -1;

// ====== CLOCK ======
function updateClock() {
    document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', {hour12:false});
}
setInterval(updateClock, 1000);
updateClock();

function fmtUptime(s) {
    if (!s || s < 0) return '--';
    const h = Math.floor(s/3600), m = Math.floor((s%3600)/60);
    return `${h}h${m}m`;
}

// ====== TERMINAL OUTPUT ======
const termOut = document.getElementById('termOutput');

function print(html, cls='') {
    const d = document.createElement('div');
    d.className = 'term-line ' + cls;
    d.innerHTML = html;
    termOut.appendChild(d);
    while (termOut.children.length > 500) termOut.removeChild(termOut.firstChild);
    termOut.scrollTop = termOut.scrollHeight;
}

function printTable(headers, rows) {
    let html = '<table class="term-table"><thead><tr>';
    headers.forEach(h => html += `<th>${h}</th>`);
    html += '</tr></thead><tbody>';
    rows.forEach(r => {
        html += '<tr>';
        r.forEach(c => html += `<td>${c}</td>`);
        html += '</tr>';
    });
    html += '</tbody></table>';
    print(html);
}

// ====== API FETCHERS ======
async function fetchJSON(url) {
    const r = await fetch(url);
    return r.json();
}

async function refreshStatus() {
    try {
        cachedStatus = await fetchJSON('/api/status');
        updateStatsBar(cachedStatus);
    } catch(e) {
        document.getElementById('statusBadge').textContent = 'OFFLINE';
        document.getElementById('statusBadge').className = 'status-badge status-offline';
    }
}

function updateStatsBar(d) {
    const badge = document.getElementById('statusBadge');
    badge.textContent = d.running ? 'LIVE' : 'OFFLINE';
    badge.className = 'status-badge ' + (d.running ? 'status-live' : 'status-offline');
    document.getElementById('uptime').textContent = 'UP ' + fmtUptime(d.uptime);
    if (d.balance !== undefined) document.getElementById('balance').textContent = '$' + d.balance.toFixed(2);
    if (d.pnl !== undefined) {
        const el = document.getElementById('pnl');
        el.textContent = (d.pnl >= 0 ? '+' : '') + '$' + d.pnl.toFixed(2);
        el.className = 'stat-value ' + (d.pnl >= 0 ? '' : 'red');
    }
    if (d.win_rate !== undefined) document.getElementById('winrate').textContent = d.win_rate + '%';
    if (d.wins !== undefined) document.getElementById('wl').textContent = d.wins + '/' + (d.losses||0);
    if (d.open_positions !== undefined) document.getElementById('positions').textContent = d.open_positions;
    if (d.scan_count !== undefined) document.getElementById('scans').textContent = d.scan_count;
}

// ====== COMMANDS ======
const COMMANDS = {
    help: {
        desc: 'Show available commands',
        run: () => {
            print('<span class="cyan bold">CYPHER GROK TRADE - Terminal v3.1</span>');
            print('<span class="dim">Available commands:</span>');
            print('');
            const cmds = [
                ['status',    'Bot status, balance, positions, config'],
                ['positions', 'Open positions with PnL'],
                ['trades',    'Trade history (last 20)'],
                ['trades all','Full trade history'],
                ['pnl',       'Accumulated PnL breakdown'],
                ['pnl daily', 'Daily PnL chart'],
                ['pnl coins', 'PnL by coin'],
                ['pnl hourly','PnL by hour of day'],
                ['signals',   'Recent signals (last 20)'],
                ['config',    'Full bot configuration'],
                ['learning',  'AI learning stats (avoid/prefer coins)'],
                ['logs',      'Recent scan logs'],
                ['lp',        'Arbitrum LP status'],
                ['copy',      'Copy trading followers'],
                ['clear',     'Clear terminal'],
                ['help',      'This help message'],
            ];
            cmds.forEach(([cmd, desc]) => {
                print(`  <span class="green">${cmd.padEnd(14)}</span> <span class="dim">${desc}</span>`);
            });
            print('');
            print('<span class="dim">Tip: use <span class="yellow">Up/Down</span> arrows for command history</span>');
        }
    },

    status: {
        desc: 'Bot status overview',
        run: async () => {
            await refreshStatus();
            const d = cachedStatus;
            if (!d) { print('<span class="red">Error: cannot fetch status</span>'); return; }
            print('<span class="cyan bold">--- BOT STATUS ---</span>');
            print(`  Running:     <span class="${d.running ? 'green' : 'red'}">${d.running ? 'YES' : 'NO'}</span>`);
            print(`  Uptime:      <span class="green">${fmtUptime(d.uptime)}</span>`);
            print(`  Balance:     <span class="green bold">$${(d.balance||0).toFixed(2)}</span>`);
            print(`  Session PnL: <span class="${(d.pnl||0)>=0?'green':'red'}">${(d.pnl||0)>=0?'+':''}$${(d.pnl||0).toFixed(4)}</span>`);
            print(`  Win Rate:    <span class="purple">${d.win_rate||0}%</span> (${d.wins||0}W / ${d.losses||0}L)`);
            print(`  Trades:      <span class="cyan">${d.trades_taken||0}</span>`);
            print(`  Open Pos:    <span class="yellow">${d.open_positions||0}</span>`);
            print(`  Scans:       <span class="orange">${d.scan_count||0}</span>`);
            print(`  Errors:      <span class="${d.errors>0?'red':'green'}">${d.errors||0}</span>`);
            if (d.config) {
                print('');
                print(`  <span class="dim">Config: ${d.config.leverage}x lev | ${d.config.pairs_count} pairs | ${d.config.min_confidence} conf | ${d.config.scan_interval}s scan</span>`);
            }
        }
    },

    positions: {
        desc: 'Open positions',
        run: async () => {
            await refreshStatus();
            const d = cachedStatus;
            if (!d || !d.positions || d.positions.length === 0) {
                print('<span class="dim">No open positions.</span>');
                return;
            }
            print('<span class="cyan bold">--- OPEN POSITIONS ---</span>');
            const rows = d.positions.map(p => [
                `<span class="cyan">${p.coin}</span>`,
                `<span class="${p.side==='LONG'?'green':'red'}">${p.side}</span>`,
                `${Math.abs(p.size).toFixed(2)}`,
                `$${Number(p.entry_price).toFixed(4)}`,
                `<span class="${p.pnl>=0?'green':'red'}">${p.pnl>=0?'+':''}$${p.pnl.toFixed(4)}</span>`,
                `${p.leverage||'-'}x`,
            ]);
            printTable(['Coin','Side','Size','Entry','PnL','Lev'], rows);
        }
    },

    trades: {
        desc: 'Trade history',
        run: async (args) => {
            if (!cachedTrades) cachedTrades = await fetchJSON('/api/trades');
            const trades = cachedTrades;
            if (!trades || trades.length === 0) { print('<span class="dim">No trades yet.</span>'); return; }

            const completed = trades.filter(t => t.result);
            const limit = args === 'all' ? completed.length : 20;
            const show = completed.slice(-limit);

            print(`<span class="cyan bold">--- TRADE HISTORY (${show.length}/${completed.length}) ---</span>`);
            const rows = show.map(t => {
                const res = t.result === 'WIN'
                    ? '<span class="green bold">WIN</span>'
                    : '<span class="red bold">LOSS</span>';
                const pnl = t.pnl !== null
                    ? `<span class="${t.pnl>=0?'green':'red'}">${t.pnl>=0?'+':''}$${t.pnl.toFixed(4)}</span>`
                    : '<span class="dim">--</span>';
                const dur = t.duration_seconds
                    ? `${Math.floor(t.duration_seconds/60)}m${Math.floor(t.duration_seconds%60)}s`
                    : '--';
                const ts = (t.timestamp_open||'').slice(5,16).replace('T',' ');
                return [
                    `<span class="dim">${ts}</span>`,
                    `<span class="cyan">${t.coin}</span>`,
                    `<span class="${t.direction==='LONG'?'green':'red'}">${t.direction}</span>`,
                    `$${Number(t.entry_price).toFixed(4)}`,
                    t.exit_price ? `$${Number(t.exit_price).toFixed(4)}` : '--',
                    pnl, res, dur,
                ];
            });
            printTable(['Time','Coin','Dir','Entry','Exit','PnL','Result','Duration'], rows);

            // Summary
            const wins = completed.filter(t=>t.result==='WIN').length;
            const losses = completed.filter(t=>t.result==='LOSS').length;
            const totalPnl = completed.reduce((s,t)=>s+(t.pnl||0), 0);
            const avgWin = wins > 0 ? completed.filter(t=>t.result==='WIN').reduce((s,t)=>s+(t.pnl||0),0)/wins : 0;
            const avgLoss = losses > 0 ? completed.filter(t=>t.result==='LOSS').reduce((s,t)=>s+(t.pnl||0),0)/losses : 0;
            print('');
            print(`  Total: <span class="cyan">${completed.length}</span> | Win Rate: <span class="purple">${completed.length>0?(wins/completed.length*100).toFixed(1):0}%</span> | PnL: <span class="${totalPnl>=0?'green':'red'}">${totalPnl>=0?'+':''}$${totalPnl.toFixed(4)}</span>`);
            print(`  Avg Win: <span class="green">$${avgWin.toFixed(4)}</span> | Avg Loss: <span class="red">$${avgLoss.toFixed(4)}</span>`);
        }
    },

    pnl: {
        desc: 'PnL analysis',
        run: async (args) => {
            if (!cachedPnl) cachedPnl = await fetchJSON('/api/pnl');
            const d = cachedPnl;
            if (d.error) { print(`<span class="red">Error: ${d.error}</span>`); return; }

            if (args === 'daily') {
                print('<span class="cyan bold">--- DAILY PNL ---</span>');
                const days = Object.entries(d.daily || {}).sort((a,b) => a[0].localeCompare(b[0]));
                if (days.length === 0) { print('<span class="dim">No daily data yet.</span>'); return; }
                const maxAbs = Math.max(...days.map(([,v]) => Math.abs(v.pnl)), 0.01);
                days.forEach(([day, v]) => {
                    const barLen = Math.round(Math.abs(v.pnl) / maxAbs * 30);
                    const bar = v.pnl >= 0
                        ? '<span class="green">' + '\u2588'.repeat(barLen) + '</span>'
                        : '<span class="red">' + '\u2588'.repeat(barLen) + '</span>';
                    const wr = v.trades > 0 ? (v.wins/v.trades*100).toFixed(0) : 0;
                    print(`  <span class="dim">${day}</span> ${bar} <span class="${v.pnl>=0?'green':'red'}">${v.pnl>=0?'+':''}$${v.pnl.toFixed(4)}</span> <span class="dim">(${v.trades}t ${wr}%wr)</span>`);
                });
                return;
            }

            if (args === 'coins') {
                print('<span class="cyan bold">--- PNL BY COIN ---</span>');
                const coins = Object.entries(d.by_coin || {}).sort((a,b) => b[1].pnl - a[1].pnl);
                if (coins.length === 0) { print('<span class="dim">No coin data yet.</span>'); return; }
                const rows = coins.map(([coin, v]) => {
                    const wr = v.trades > 0 ? (v.wins/v.trades*100).toFixed(0)+'%' : '--';
                    return [
                        `<span class="cyan">${coin}</span>`,
                        `<span class="${v.pnl>=0?'green':'red'}">${v.pnl>=0?'+':''}$${v.pnl.toFixed(4)}</span>`,
                        `${v.trades}`,
                        `<span class="green">${v.wins}</span>`,
                        `<span class="red">${v.losses}</span>`,
                        `<span class="purple">${wr}</span>`,
                    ];
                });
                printTable(['Coin','PnL','Trades','Wins','Losses','WR%'], rows);
                return;
            }

            if (args === 'hourly') {
                print('<span class="cyan bold">--- PNL BY HOUR (UTC) ---</span>');
                const hours = Object.entries(d.hourly || {}).sort((a,b) => Number(a[0]) - Number(b[0]));
                if (hours.length === 0) { print('<span class="dim">No hourly data yet.</span>'); return; }
                const maxAbs = Math.max(...hours.map(([,v]) => Math.abs(v.pnl)), 0.01);
                hours.forEach(([hour, v]) => {
                    const barLen = Math.round(Math.abs(v.pnl) / maxAbs * 25);
                    const bar = v.pnl >= 0
                        ? '<span class="green">' + '\u2588'.repeat(barLen) + '</span>'
                        : '<span class="red">' + '\u2588'.repeat(barLen) + '</span>';
                    const wr = v.trades > 0 ? (v.wins/v.trades*100).toFixed(0) : 0;
                    print(`  <span class="dim">${hour.padStart(2,'0')}:00</span> ${bar} <span class="${v.pnl>=0?'green':'red'}">${v.pnl>=0?'+':''}$${v.pnl.toFixed(4)}</span> <span class="dim">(${v.trades}t ${wr}%wr)</span>`);
                });
                return;
            }

            // Default: overview
            print('<span class="cyan bold">--- PNL OVERVIEW ---</span>');
            print(`  Total PnL:   <span class="${d.total_pnl>=0?'green':'red'} bold">${d.total_pnl>=0?'+':''}$${d.total_pnl.toFixed(4)}</span>`);
            print('');

            // Cumulative mini-chart (last 30 trades)
            const cum = (d.cumulative || []).slice(-30);
            if (cum.length > 0) {
                print('  <span class="dim">Cumulative PnL (last 30 trades):</span>');
                const vals = cum.map(c => c.cumulative);
                const mn = Math.min(...vals, 0);
                const mx = Math.max(...vals, 0);
                const range = mx - mn || 1;
                const chartH = 8;
                const lines = [];
                for (let row = chartH - 1; row >= 0; row--) {
                    let line = '  ';
                    const threshold = mn + (range * row / (chartH - 1));
                    for (let i = 0; i < cum.length; i++) {
                        if (cum[i].cumulative >= threshold) {
                            line += cum[i].cumulative >= 0 ? '<span class="green">\u2588</span>' : '<span class="red">\u2588</span>';
                        } else {
                            line += ' ';
                        }
                    }
                    lines.push(line);
                }
                lines.forEach(l => print(l));
                print(`  <span class="dim">${''.padStart(cum.length, '\u2500')}</span>`);
            }

            print('');
            print(`  <span class="dim">Use: <span class="yellow">pnl daily</span> | <span class="yellow">pnl coins</span> | <span class="yellow">pnl hourly</span></span>`);
        }
    },

    signals: {
        desc: 'Recent signals',
        run: async () => {
            if (!cachedSignals) cachedSignals = await fetchJSON('/api/signals');
            const sigs = cachedSignals;
            if (!sigs || sigs.length === 0) { print('<span class="dim">No signals yet.</span>'); return; }
            const show = sigs.slice(-20);
            print(`<span class="cyan bold">--- RECENT SIGNALS (${show.length}/${sigs.length}) ---</span>`);
            const rows = show.map(s => {
                const ts = (s.timestamp||'').slice(5,16).replace('T',' ');
                const approved = s.approved
                    ? '<span class="green">YES</span>'
                    : '<span class="red">NO</span>';
                return [
                    `<span class="dim">${ts}</span>`,
                    `<span class="cyan">${s.coin}</span>`,
                    `<span class="${s.direction==='LONG'?'green':'red'}">${s.direction}</span>`,
                    `<span class="purple">${(s.confidence||0).toFixed(2)}</span>`,
                    `<span class="dim">${s.trend_5m||'?'}</span>`,
                    `<span class="dim">${s.grok?.action||'?'}</span>`,
                    approved,
                ];
            });
            printTable(['Time','Coin','Dir','Conf','5mTrend','Grok','Approved'], rows);
        }
    },

    config: {
        desc: 'Full config',
        run: async () => {
            if (!cachedConfig) cachedConfig = await fetchJSON('/api/config');
            const cfg = cachedConfig;
            if (cfg.error) { print(`<span class="red">Error: ${cfg.error}</span>`); return; }
            print('<span class="cyan bold">--- CONFIGURATION ---</span>');
            const keys = Object.keys(cfg).sort();
            keys.forEach(k => {
                let v = cfg[k];
                let cls = 'green';
                if (v === '***HIDDEN***') cls = 'red';
                else if (typeof v === 'object') v = JSON.stringify(v);
                else if (typeof v === 'boolean') { cls = v ? 'green' : 'red'; }
                print(`  <span class="dim">${k.padEnd(30)}</span> <span class="${cls}">${v}</span>`);
            });
        }
    },

    learning: {
        desc: 'Learning stats',
        run: async () => {
            if (!cachedLearning) cachedLearning = await fetchJSON('/api/learning');
            const d = cachedLearning;
            if (d.error || d.message) {
                print(`<span class="dim">${d.message || d.error}</span>`);
                return;
            }
            print('<span class="cyan bold">--- LEARNING STATS ---</span>');

            // Coin stats
            const coins = Object.entries(d.coin_stats || {}).sort((a,b) => (b[1].win_rate||0) - (a[1].win_rate||0));
            if (coins.length > 0) {
                print('');
                print('  <span class="yellow bold">Coin Performance:</span>');
                const rows = coins.map(([coin, s]) => {
                    const total = s.wins + s.losses;
                    const wr = (s.win_rate * 100).toFixed(0);
                    const wrCls = s.win_rate >= 0.5 ? 'green' : s.win_rate >= 0.3 ? 'yellow' : 'red';
                    return [
                        `<span class="cyan">${coin}</span>`,
                        `<span class="${wrCls}">${wr}%</span>`,
                        `${s.wins}`,
                        `${s.losses}`,
                        `${total}`,
                        `<span class="${s.total_pnl>=0?'green':'red'}">$${s.total_pnl.toFixed(4)}</span>`,
                    ];
                });
                printTable(['Coin','WR','Wins','Losses','Total','PnL'], rows);
            }

            // Avoid patterns
            const avoid = d.avoid_patterns || [];
            if (avoid.length > 0) {
                print('');
                print('  <span class="red bold">Avoid List (WR < 30%, 5+ trades):</span>');
                avoid.forEach(p => print(`    <span class="red">${p.coin}</span> <span class="dim">WR: ${(p.win_rate*100).toFixed(0)}% (${p.trades} trades)</span>`));
            }

            // Prefer patterns
            const prefer = d.prefer_patterns || [];
            if (prefer.length > 0) {
                print('');
                print('  <span class="green bold">Prefer List (WR >= 65%, 5+ trades):</span>');
                prefer.forEach(p => print(`    <span class="green">${p.coin}</span> <span class="dim">WR: ${(p.win_rate*100).toFixed(0)}% (${p.trades} trades)</span>`));
            }

            // Best hours
            const hours = d.timeframe_stats || {};
            const goodHours = Object.entries(hours)
                .filter(([,s]) => (s.wins+s.losses) >= 3 && s.win_rate >= 0.6)
                .map(([h,s]) => `${h}:00 (${(s.win_rate*100).toFixed(0)}%)`)
                .join(', ');
            if (goodHours) {
                print('');
                print(`  <span class="purple bold">Best Hours:</span> <span class="green">${goodHours}</span>`);
            }
        }
    },

    logs: {
        desc: 'Recent scan logs',
        run: async () => {
            await refreshStatus();
            const logs = cachedStatus?.recent_logs || [];
            if (logs.length === 0) { print('<span class="dim">No logs yet.</span>'); return; }
            print('<span class="cyan bold">--- SCAN LOG ---</span>');
            logs.forEach(log => {
                let cls = 'dim';
                if (log.includes('ENTRY') || log.includes('LONG')) cls = 'green';
                else if (log.includes('SHORT')) cls = 'red';
                else if (log.includes('WIN')) cls = 'green bold';
                else if (log.includes('LOSS')) cls = 'red bold';
                else if (log.includes('ERROR')) cls = 'red';
                else if (log.includes('GROK')) cls = 'purple';
                else if (log.includes('Cycle')) cls = 'cyan';
                print(`  ${log}`, cls);
            });
        }
    },

    lp: {
        desc: 'LP status',
        run: async () => {
            await refreshStatus();
            const lp = cachedStatus?.lp;
            if (!lp) { print('<span class="dim">No LP data.</span>'); return; }
            print('<span class="purple bold">--- ARBITRUM LP ---</span>');
            print(`  Active:  <span class="${lp.active?'green':'red'}">${lp.active?'YES':'NO'}</span>`);
            print(`  Pool:    <span class="cyan">${lp.pool||'--'}</span>`);
            print(`  TokenID: <span class="yellow">${lp.token_id ? '#'+lp.token_id : '--'}</span>`);
            print(`  Fees:    <span class="green">$${(lp.fees_collected||0).toFixed(4)}</span>`);
        }
    },

    copy: {
        desc: 'Copy trading',
        run: async () => {
            await refreshStatus();
            const cp = cachedStatus?.copy;
            if (!cp) { print('<span class="dim">No copy trading data.</span>'); return; }
            print('<span class="pink bold">--- COPY TRADING ---</span>');
            print(`  Total Fees: <span class="green">$${(cp.total_fees_collected||0).toFixed(4)}</span>`);
            const followers = cp.followers || [];
            if (followers.length === 0) {
                print('  <span class="dim">No followers connected.</span>');
                return;
            }
            const rows = followers.map(f => [
                `<span class="pink">${f.name}</span>`,
                `<span class="dim">${f.wallet}</span>`,
                `<span class="cyan">$${(f.hl_balance||0).toFixed(2)}</span>`,
                f.lp ? `<span class="purple">${f.lp.pool}</span>` : '<span class="dim">--</span>',
                `<span class="yellow">$${(f.pending_fees||0).toFixed(4)}</span>`,
            ]);
            printTable(['Name','Wallet','Balance','LP Pool','Pending Fees'], rows);
        }
    },

    clear: {
        desc: 'Clear terminal',
        run: () => { termOut.innerHTML = ''; }
    },
};

// ====== COMMAND PARSER ======
async function execCmd(input) {
    const raw = input.trim();
    if (!raw) return;

    // Show typed command
    print(`<span class="prompt">cypher $</span> <span class="cmd">${raw}</span>`);

    const parts = raw.split(/\s+/);
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1).join(' ');

    if (COMMANDS[cmd]) {
        try {
            await COMMANDS[cmd].run(args);
        } catch(e) {
            print(`<span class="red">Error: ${e.message}</span>`);
        }
    } else {
        print(`<span class="red">Unknown command: ${cmd}</span>`);
        print('<span class="dim">Type <span class="cyan">help</span> for available commands.</span>');
    }
    print('');
}

// ====== INPUT HANDLING ======
const termInput = document.getElementById('termInput');
termInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
        const val = termInput.value;
        termInput.value = '';
        if (val.trim()) {
            cmdHistory.push(val);
            cmdIdx = cmdHistory.length;
        }
        await execCmd(val);
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (cmdIdx > 0) {
            cmdIdx--;
            termInput.value = cmdHistory[cmdIdx];
        }
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (cmdIdx < cmdHistory.length - 1) {
            cmdIdx++;
            termInput.value = cmdHistory[cmdIdx];
        } else {
            cmdIdx = cmdHistory.length;
            termInput.value = '';
        }
    }
});

// Focus input on click anywhere
document.addEventListener('click', () => termInput.focus());

// ====== BOOT SEQUENCE ======
async function boot() {
    const lines = [
        ['[BOOT] CypherGrokTrade v3.1 Terminal', 'cyan'],
        ['[BOOT] Connecting to Hyperliquid...', 'dim'],
        ['[BOOT] Loading SMC Engine + MA Scalper...', 'dim'],
        ['[BOOT] Grok AI online.', 'purple'],
        ['[BOOT] System ready.', 'green bold'],
        ['', ''],
    ];
    for (const [text, cls] of lines) {
        print(text, cls);
        await new Promise(r => setTimeout(r, 150 + Math.random() * 200));
    }
    // Auto-run status
    await COMMANDS.status.run();
    print('');
    print('<span class="dim">Type <span class="cyan">help</span> for commands | Auto-refresh every 10s</span>');
    print('');
}
boot();

// ====== AUTO REFRESH ======
setInterval(async () => {
    // Invalidate caches
    cachedTrades = null;
    cachedPnl = null;
    cachedSignals = null;
    cachedLearning = null;
    cachedConfig = null;
    await refreshStatus();

    // Update totalPnl from pnl endpoint
    try {
        const pnlData = await fetchJSON('/api/pnl');
        const el = document.getElementById('totalPnl');
        el.textContent = (pnlData.total_pnl >= 0 ? '+' : '') + '$' + pnlData.total_pnl.toFixed(2);
        el.className = 'stat-value ' + (pnlData.total_pnl >= 0 ? '' : 'red');
    } catch(e) {}
}, 10000);

// Initial totalPnl fetch
(async () => {
    try {
        const pnlData = await fetchJSON('/api/pnl');
        const el = document.getElementById('totalPnl');
        el.textContent = (pnlData.total_pnl >= 0 ? '+' : '') + '$' + pnlData.total_pnl.toFixed(2);
        el.className = 'stat-value ' + (pnlData.total_pnl >= 0 ? '' : 'red');
    } catch(e) {}
})();
</script>
</body>
</html>
